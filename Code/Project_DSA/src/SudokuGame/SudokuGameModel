package SudokuGame;

class SudokuGameModel {
    public static final int GRID_SIZE = 9;
    public static final int BOX_SIZE = 3;
    
    public enum GameState { PLAYING, COMPLETED, PAUSED }
    
    public enum Difficulty {
        EASY(45, "Easy"), MEDIUM(35, "Medium"), 
        HARD(25, "Hard"), EXPERT(20, "Expert");
        
        private final int filledCells;
        private final String name;
        
        Difficulty(int filledCells, String name) {
            this.filledCells = filledCells;
            this.name = name;
        }
        
        public int getFilledCells() { return filledCells; }
        public String getName() { return name; }
    }
    
    private SudokuCell[][] grid;
    private SudokuCell[][] solution;
    private GameState gameState;
    private Difficulty difficulty;
    private long startTime;
    private long elapsedTime;
    private boolean timerRunning;
    private int mistakeCount;
    private int maxMistakes = 3;
    private int hintsUsed;
    private boolean checkingEnabled = true;
    
    // Command Pattern for Undo/Redo
    private List<SudokuCommand> commandHistory;
    private static final int MAX_HISTORY = 50;
    
    // Observer Pattern
    private List<SudokuGameListener> listeners;
    
    public SudokuGameModel() {
        this.grid = new SudokuCell[GRID_SIZE][GRID_SIZE];
        this.solution = new SudokuCell[GRID_SIZE][GRID_SIZE];
        this.difficulty = Difficulty.EASY;
        this.gameState = GameState.PLAYING;
        this.commandHistory = new ArrayList<>();
        this.listeners = new ArrayList<>();
        
        initializeGrid();
        generateNewPuzzle();
    }
    
    private void initializeGrid() {
        for (int row = 0; row < GRID_SIZE; row++) {
            for (int col = 0; col < GRID_SIZE; col++) {
                grid[row][col] = new SudokuCell(row, col);
                solution[row][col] = new SudokuCell(row, col);
            }
        }
    }
    
    public void newGame() {
        gameState = GameState.PLAYING;
        mistakeCount = 0;
        hintsUsed = 0;
        elapsedTime = 0;
        timerRunning = false;
        commandHistory.clear();
        
        initializeGrid();
        generateNewPuzzle();
        notifyGameStateChanged();
    }
    
    public void generateNewPuzzle() {
        // Generate complete solution
        generateCompleteSolution();
        
        // Copy solution to grid
        copyArray(solution, grid);
        
        // Remove cells according to difficulty
        removeCells();
        
        // Mark remaining cells as fixed
        markFixedCells();
        
        startTimer();
    }
    
    private void generateCompleteSolution() {
        // Clear solution grid
        for (int row = 0; row < GRID_SIZE; row++) {
            for (int col = 0; col < GRID_SIZE; col++) {
                solution[row][col].setValue(0);
            }
        }
        
        // Fill using backtracking with randomization
        solveSudoku(solution);
    }
    
    private boolean solveSudoku(SudokuCell[][] board) {
        for (int row = 0; row < GRID_SIZE; row++) {
            for (int col = 0; col < GRID_SIZE; col++) {
                if (board[row][col].isEmpty()) {
                    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
                    Collections.shuffle(numbers);
                    
                    for (int num : numbers) {
                        if (isValidMove(board, row, col, num)) {
                            board[row][col].setValue(num);
                            if (solveSudoku(board)) {
                                return true;
                            }
                            board[row][col].setValue(0);
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
    
    private void removeCells() {
        Random random = new Random();
        int cellsToRemove = GRID_SIZE * GRID_SIZE - difficulty.getFilledCells();
        
        for (int i = 0; i < cellsToRemove; i++) {
            int row, col;
            do {
                row = random.nextInt(GRID_SIZE);
                col = random.nextInt(GRID_SIZE);
            } while (grid[row][col].isEmpty());
            
            grid[row][col].setValue(0);
        }
    }
    
    private void markFixedCells() {
        for (int row = 0; row < GRID_SIZE; row++) {
            for (int col = 0; col < GRID_SIZE; col++) {
                if (!grid[row][col].isEmpty()) {
                    grid[row][col].setFixed(true);
                }
            }
        }
    }
    
    private void copyArray(SudokuCell[][] source, SudokuCell[][] dest) {
        for (int row = 0; row < GRID_SIZE; row++) {
            for (int col = 0; col < GRID_SIZE; col++) {
                dest[row][col] = new SudokuCell(source[row][col]);
            }
        }
    }
    
    public boolean makeMove(int row, int col, int value) {
        if (!isValidCell(row, col) || gameState != GameState.PLAYING) {
            return false;
        }
        
        SudokuCell cell = grid[row][col];
        if (!cell.canEdit()) {
            return false;
        }
        
        // Create and execute command
        SudokuCommand command = new SetValueCommand(this, row, col, cell.getValue(), value);
        executeCommand(command);
        
        return true;
    }
    
    public void executeCommand(SudokuCommand command) {
        command.execute();
        commandHistory.add(command);
        
        if (commandHistory.size() > MAX_HISTORY) {
            commandHistory.remove(0);
        }
        
        updateGameState();
        notifyGameStateChanged();
    }
    
    public boolean undo() {
        if (commandHistory.isEmpty() || gameState != GameState.PLAYING) {
            return false;
        }
        
        SudokuCommand lastCommand = commandHistory.remove(commandHistory.size() - 1);
        lastCommand.undo();
        
        updateGameState();
        notifyGameStateChanged();
        return true;
    }
    
    public boolean isValidMove(SudokuCell[][] board, int row, int col, int value) {
        if (!isValidCell(row, col) || value < 1 || value > 9) {
            return false;
        }
        
        // Check row
        for (int c = 0; c < GRID_SIZE; c++) {
            if (c != col && board[row][c].getValue() == value) {
                return false;
            }
        }
        
        // Check column
        for (int r = 0; r < GRID_SIZE; r++) {
            if (r != row && board[r][col].getValue() == value) {
                return false;
            }
        }
        
        // Check 3x3 box
        int boxRow = (row / BOX_SIZE) * BOX_SIZE;
        int boxCol = (col / BOX_SIZE) * BOX_SIZE;
        
        for (int r = boxRow; r < boxRow + BOX_SIZE; r++) {
            for (int c = boxCol; c < boxCol + BOX_SIZE; c++) {
                if (r != row && c != col && board[r][c].getValue() == value) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    public void giveHint() {
        if (gameState != GameState.PLAYING) return;
        
        for (int row = 0; row < GRID_SIZE; row++) {
            for (int col = 0; col < GRID_SIZE; col++) {
                if (grid[row][col].isEmpty() && grid[row][col].canEdit()) {
                    int correctValue = solution[row][col].getValue();
                    makeMove(row, col, correctValue);
                    grid[row][col].setShowingHint(true);
                    hintsUsed++;
                    return;
                }
            }
        }
    }
    
    public void validateGrid() {
        if (!checkingEnabled) return;
        
        for (int row = 0; row < GRID_SIZE; row++) {
            for (int col = 0; col < GRID_SIZE; col++) {
                grid[row][col].setError(false);
            }
        }
        
        for (int row = 0; row < GRID_SIZE; row++) {
            for (int col = 0; col < GRID_SIZE; col++) {
                SudokuCell cell = grid[row][col];
                if (!cell.isEmpty() && !isValidMove(grid, row, col, cell.getValue())) {
                    cell.setError(true);
                }
            }
        }
    }
    
    private void updateGameState() {
        validateGrid();
        
        if (isPuzzleComplete()) {
            gameState = GameState.COMPLETED;
            stopTimer();
        }
    }
    
    private boolean isPuzzleComplete() {
        for (int row = 0; row < GRID_SIZE; row++) {
            for (int col = 0; col < GRID_SIZE; col++) {
                SudokuCell cell = grid[row][col];
                if (cell.isEmpty() || cell.hasError()) {
                    return false;
                }
            }
        }
        return true;
    }
    
    public void startTimer() {
        startTime = System.currentTimeMillis();
        timerRunning = true;
    }
    
    public void stopTimer() {
        if (timerRunning) {
            elapsedTime += System.currentTimeMillis() - startTime;
            timerRunning = false;
        }
    }
    
    public void pauseGame() {
        if (gameState == GameState.PLAYING) {
            gameState = GameState.PAUSED;
            stopTimer();
            notifyGameStateChanged();
        }
    }
    
    public void resumeGame() {
        if (gameState == GameState.PAUSED) {
            gameState = GameState.PLAYING;
            startTimer();
            notifyGameStateChanged();
        }
    }
    
    // Getters
    public SudokuCell getCell(int row, int col) {
        if (isValidCell(row, col)) {
            return grid[row][col];
        }
        return null;
    }
    
    public boolean isValidCell(int row, int col) {
        return row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE;
    }
    
    public GameState getGameState() { return gameState; }
    public Difficulty getDifficulty() { return difficulty; }
    public int getMistakeCount() { return mistakeCount; }
    public int getMaxMistakes() { return maxMistakes; }
    public int getHintsUsed() { return hintsUsed; }
    public boolean canUndo() { return !commandHistory.isEmpty(); }
    public boolean isCheckingEnabled() { return checkingEnabled; }
    
    public long getElapsedTime() {
        if (timerRunning) {
            return elapsedTime + (System.currentTimeMillis() - startTime);
        }
        return elapsedTime;
    }
    
    public void setDifficulty(Difficulty difficulty) { this.difficulty = difficulty; }
    public void setCheckingEnabled(boolean enabled) { this.checkingEnabled = enabled; }
    
    // Observer Pattern Implementation
    public void addGameListener(SudokuGameListener listener) {
        listeners.add(listener);
    }
    
    public void removeGameListener(SudokuGameListener listener) {
        listeners.remove(listener);
    }
    
    private void notifyGameStateChanged() {
        for (SudokuGameListener listener : listeners) {
            listener.onGameStateChanged(gameState);
        }
    }
}